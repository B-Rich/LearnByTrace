# Overview #

**Learn By Trace** is a Django application for displaying code traces in a way that is easy to read, interactive, and focused on learning (rather than debugging).

In Learn By Trace, xml markup for a code trace is generated using annotation functions, then the resulting markup tree is traversed with javascript to produce a collapsible, interactive trace tree in the browser. Relevant nodes in the trace tree (e.g., variable updates) are linked visually with corresponding lines in pseudocode for the algorithm so that itâ€™s easy to make the connection between psuedocode and execution trace as you explore.

## Models ##

There are only two models right now, Algorithm and ExecutionTrace. Each Algorithm has its own pseudocode file and is connected to 0 or more ExecutionTraces. An ExecutionTrace is just that, the trace of one particular run of the Algorithm on a particular input, producing a particular output. 

For example, to demonstrate Insertion Sort you would want to create one Algorithm called Insertion Sort, with the associated pseudocode. Then, to demonstrate the various characteristics of Insertion Sort it would probably make sense to have at least two ExecutionTraces: one which starts with a random list and another which starts with a list that's already sorted.

## What is this trace XML file and where does it come from? ##

The XML markup is generated by adding annotation function calls to source code you've written to translate the pseudocode for an algorithm into actual code. The annotations are things like mentioning when a loop variable is updated, when functions are called, along with the corresponding line numbers in the psuedocode. 

It's all manual right now, but it would be cool to do it automatically someday. I've included the annotation functions I use in a file called TraceLogger.py - you can find it on the website along with a more detailed explanation [here](http://lifeasymptotic.com/learnbytrace/add/).

## JavaScript in the ExecutionTrace detail template ##

When you visit a trace detail page, the Django view opens the pseudocode text file of the associated algorithm and puts each line into a dictionary indexed by line number. Django does nothing with the trace XML markup, that is all done on the client side with JavaScript.

In the template, I use the server-side include tag to include the contents of the trace XML in the template at parsing time. It's important that it not be included as content, because I want the browser to do the work of parsing out the XML into a nice tree structure in the DOM.  Because of the SSI you need to add ALLOWED_INCLUDE_ROOTS to your Django settings file: I just have a tuple mapping MEDIA_ROOT/learnbytrace to MEDIA_URL/learnbytrace.

Once the template loads it fires off a script which finds the root <trace> tag in the DOM tree for the document and then processes each node recursively to build a collapsible list. The structure of the generated markup is taken from the Chrome XML viewer, and nodes are expanded or collapsed by adding or removing a "hidden" style class to two paralell div elements.

The JavaScript also adds a behavior to all nodes. When clicked the nodes in the trace tree is highlighted and if the XML markup which generated the node has a lineNumber attribute (e.g., a variable update or the start of a function), it will also highlight that line number in the pseudocode on the page. The behavior cascades up, so if a node doesn't have a line number itself it will highlight the line number of the closest enclosing node.

I use eval as a hack to easily parse lists and dictionaries printed out from Python into JavaScript. This only works because they both use the same syntax.